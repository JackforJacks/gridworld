// Tiles API Route - READ-ONLY endpoint
// Tile generation is handled exclusively by /api/worldrestart
import express, { Request, Response } from 'express';
import villageService from '../services/villageService';
import serverConfig from '../config/server';
import storage from '../services/storage';
import Hexasphere from '../../src/core/hexasphere/HexaSphere';

// Interfaces for tile data
interface LandData {
    tile_id: number;
    chunk_index: number;
    land_type: string;
    cleared: boolean;
    village_id?: number;
    village_name?: string;
    housing_slots?: number;
    housing_capacity?: number;
    food_stores?: number;
    food_capacity?: number;
    food_production_rate?: number;
    last_food_update?: string;
}

interface VillageData {
    id: number;
    name: string;
    tile_id: number;
    land_chunk_index: number;
    housing_slots: number;
    housing_capacity: number;
    food_stores: number;
    food_capacity: number;
    food_production_rate: number;
    last_food_update: string;
}

// __dirname is available in CommonJS mode (our server target)

const router: express.Router = express.Router();

// Helper: parse float with fallback
function parseParam(val: unknown, fallback: number): number {
    const n = parseFloat(String(val));
    return isNaN(n) ? fallback : n;
}

// Store a consistent world seed for persistent tile generation
let worldSeed: number | null = null;

// Load world seed from environment variable or use default
function loadWorldSeed() {
    if (serverConfig.verboseLogs) {
        console.log(`[API /api/tiles] Environment WORLD_SEED: ${process.env.WORLD_SEED}`);
    }
    if (process.env.WORLD_SEED) {
        worldSeed = parseInt(process.env.WORLD_SEED);
        if (serverConfig.verboseLogs) console.log(`[API /api/tiles] Using world seed from environment: ${worldSeed}`);
    } else {
        worldSeed = 12345; // Default seed
        if (serverConfig.verboseLogs) console.log(`[API /api/tiles] Using default world seed: ${worldSeed}`);
    }
}

// Initialize seed on module load
loadWorldSeed();

// GET /api/tiles
// READ-ONLY endpoint - returns tiles from Redis (generated by /api/worldrestart)
// Does NOT regenerate tiles - use /api/worldrestart for that
router.get('/', async (req: Request, res: Response): Promise<void> => {
    const startTime = Date.now();
    
    // If client requests regeneration, redirect them to the proper endpoint
    if (req.query.regenerate === 'true' || req.query.t) {
        res.status(400).json({
            error: 'Tile regeneration via /api/tiles is deprecated',
            message: 'Use POST /api/worldrestart with { "confirm": "DELETE_ALL_DATA" } instead',
            hint: 'This endpoint is now read-only'
        });
        return;
    }

    try {
        // Parse hexasphere params for geometry only
        const radius = parseParam(req.query.radius, parseFloat(process.env.HEXASPHERE_RADIUS || '30'));
        const subdivisions = parseParam(req.query.subdivisions, parseFloat(process.env.HEXASPHERE_SUBDIVISIONS || '3'));
        const tileWidthRatio = parseParam(req.query.tileWidthRatio, parseFloat(process.env.HEXASPHERE_TILE_WIDTH_RATIO || '1'));

        // Create hexasphere for geometry (boundary points, neighbor IDs)
        const hexasphere = new Hexasphere(radius, subdivisions, tileWidthRatio);

        // Batch fetch all Redis data upfront (optimized)
        const [allTileData, allLandsData, allVillageData] = await Promise.all([
            storage.hgetall('tile'),
            storage.hgetall('tile:lands'),
            storage.hgetall('village')
        ]);

        if (!allTileData || Object.keys(allTileData).length === 0) {
            // No tiles in Redis - world needs to be initialized
            res.status(503).json({
                error: 'World not initialized',
                message: 'No tiles found in Redis. Call POST /api/worldrestart to initialize the world.'
            });
            return;
        }

        // Build village lookup by tile_id:chunk_index for O(1) access
        const villageLookup = new Map<string, VillageData>();
        for (const [, villageJson] of Object.entries(allVillageData || {})) {
            try {
                const village: VillageData = JSON.parse(villageJson as string);
                const key = `${village.tile_id}:${village.land_chunk_index}`;
                villageLookup.set(key, village);
            } catch (e: unknown) {
                // Skip malformed village data
            }
        }

        // Collect village IDs for food updates
        const villageIdsToUpdate = new Set<number>();

        // Build tile response by combining hexasphere geometry with Redis data
        const tiles = hexasphere.tiles.map(tile => {
            const props = tile.getProperties ? tile.getProperties() : tile;
            const tileId = props.id;

            // Get geometry from hexasphere
            props.boundary = tile.boundary ? tile.boundary.map(p => ({ x: p.x, y: p.y, z: p.z })) : [];
            props.centerPoint = tile.centerPoint ? {
                x: tile.centerPoint.x,
                y: tile.centerPoint.y,
                z: tile.centerPoint.z
            } : undefined;

            // Get terrain/biome data from Redis (source of truth)
            const tileDataJson = allTileData[tileId.toString()];
            if (tileDataJson) {
                try {
                    const tileData = JSON.parse(tileDataJson);
                    props.terrainType = tileData.terrain_type;
                    props.isLand = tileData.is_land;
                    props.biome = tileData.biome;
                    props.fertility = tileData.fertility;
                    props.Habitable = tileData.is_habitable ? 'yes' : 'no';
                } catch (e: unknown) {
                    // Use hexasphere defaults if parse fails
                }
            }

            // Get lands from Redis
            const landsDataJson = allLandsData?.[tileId.toString()];
            if (landsDataJson) {
                try {
                    const landsData = JSON.parse(landsDataJson);
                    // Add village information to lands
                    props.lands = landsData.map((land: LandData) => {
                        const lookupKey = `${land.tile_id}:${land.chunk_index}`;
                        const village = villageLookup.get(lookupKey);
                        if (village) {
                            villageIdsToUpdate.add(village.id);
                            return {
                                ...land,
                                village_id: village.id,
                                village_name: village.name,
                                housing_slots: village.housing_slots,
                                housing_capacity: village.housing_capacity,
                                food_stores: village.food_stores,
                                food_capacity: village.food_capacity,
                                food_production_rate: village.food_production_rate,
                                last_food_update: village.last_food_update
                            };
                        }
                        return land;
                    });
                } catch (e: unknown) {
                    props.lands = [];
                }
            } else {
                props.lands = [];
            }

            return props;
        });

        // Update food production for villages (batched)
        if (villageIdsToUpdate.size > 0) {
            await Promise.all(
                Array.from(villageIdsToUpdate).map(async villageId => {
                    try {
                        await villageService.updateVillageFoodProduction(villageId);
                        await villageService.updateVillageFoodStores(villageId);
                    } catch (err: unknown) {
                        // Ignore food update errors
                    }
                })
            );
        }

        const elapsed = Date.now() - startTime;
        if (serverConfig.verboseLogs) {
            console.log(`[API /api/tiles] Returned ${tiles.length} tiles in ${elapsed}ms`);
        }

        res.json({ tiles });
    } catch (err: unknown) {
        const error = err as Error;
        res.status(500).json({ error: 'Failed to fetch tiles', details: error.message });
    }
});

// POST /api/tiles/restart - DEPRECATED: use /api/worldrestart
router.post('/restart', async (_req: Request, res: Response): Promise<void> => {
    res.status(410).json({ success: false, message: '/api/tiles/restart is deprecated - use /api/worldrestart' });
});

// GET /api/tiles/seed - Get current world seed
router.get('/seed', (_req: Request, res: Response): void => {
    res.json({
        seed: worldSeed,
        isInitialized: worldSeed !== null
    });
});

export default router;
