jest.mock('../../services/storage', () => {
    const MemoryAdapter = require('../../services/storage/memoryAdapter');
    const inst = new MemoryAdapter();
    return { getAdapter: () => inst };
});









































/* cleaned */        await releaseLock(key, t2);        // clean up        expect(t2).toBeTruthy();        const t2 = await acquireLock(key, 500, 200, 10);        await sleep(80);        // wait for expiry        expect(t1).toBeTruthy();        const t1 = await acquireLock(key, 50, 200, 10);        const key = 'test:lock:3';    test('lock expires and allows reacquire', async () => {    });        await releaseLock(key, token1);        expect(token2).toBeNull();        const token2 = await acquireLock(key, 500, 200, 10);        expect(token1).toBeTruthy();        const token1 = await acquireLock(key, 500, 200, 10);        const key = 'test:lock:2';    test('concurrent acquire is blocked', async () => {    });        expect(released).toBe(true);        const released = await releaseLock(key, token);        expect(token).toBeTruthy();        const token = await acquireLock(key, 500, 200, 10);        const key = 'test:lock:1';    test('acquire and release succesful', async () => {describe('lock (memory adapter fallback)', () => {function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }const { acquireLock, releaseLock } = require('../lock');});    return { getAdapter: () => inst };    const inst = new MemoryAdapter();    const MemoryAdapter = require('../../services/storage/memoryAdapter');    const MemoryAdapter = require('../../services/storage/memoryAdapter');
    const inst = new MemoryAdapter();
    return {
        getAdapter: () => inst
    };
});

const { acquireLock, releaseLock } = require('../lock');

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

describe('lock (memory adapter fallback)', () => {
    test('acquire and release succesful', async () => {
        const key = 'test:lock:1';
        const token = await acquireLock(key, 500, 200, 10);
        expect(token).toBeTruthy();
        const released = await releaseLock(key, token);
        expect(released).toBe(true);
    });

    test('concurrent acquire is blocked', async () => {
        const key = 'test:lock:2';
        const token1 = await acquireLock(key, 500, 200, 10);
        expect(token1).toBeTruthy();

        const token2 = await acquireLock(key, 500, 200, 10);
        expect(token2).toBeNull();

        await releaseLock(key, token1);
    });

    test('lock expires and allows reacquire', async () => {
        const key = 'test:lock:3';
        const t1 = await acquireLock(key, 50, 200, 10);
        expect(t1).toBeTruthy();
        await sleep(80);
        const t2 = await acquireLock(key, 500, 200, 10);
        expect(t2).toBeTruthy();
        await releaseLock(key, t2);
    });
    test('acquire and release lock', async () => {
        const key = 'test:lock1';
        const token = await lock.acquireLock(key, 1000, 200, 20);
        expect(token).toBeTruthy();
        const released = await lock.releaseLock(key, token);
        expect(released).toBe(true);
    });

    test('second acquire blocked while held', async () => {
        const key = 'test:lock2';
        const t1 = await lock.acquireLock(key, 500, 200, 20);
        expect(t1).toBeTruthy();
        const t2 = await lock.acquireLock(key, 500, 200, 20);
        expect(t2).toBeNull();
        const r = await lock.releaseLock(key, t1);
        expect(r).toBe(true);
    });

    test('lock expires allowing new acquirer', async () => {
        const key = 'test:lock3';
        const t1 = await lock.acquireLock(key, 50, 200, 10);
        expect(t1).toBeTruthy();
        // wait for ttl to expire
        await sleep(80);
        const t2 = await lock.acquireLock(key, 500, 200, 20);
        expect(t2).toBeTruthy();
        await lock.releaseLock(key, t2);
    });
});